# 3D Motion Planning

## Explain the Starter Code ##

### *Explain the functionality of what's provided in `motion_planning.py` and `planning_utils.py`* ###

The file `motion_planning.py` replaces the fixed box path generated by `calculate_box()` in `backyard_flyer_solution.py` with the `send_waypoints()` and `plan_path()` functions to generate a path to a designated goal.

In `plan_path()`, a `TARGET_ALTITUDE` and `SAFETY_DISTANCE` are designated. Then, using the function `create_grid()` from `planning_utils.py`, an occupancy grid is generated from `colliders.csv`, `TARGET_ALTITUDE`, and `SAFETY_DISTANCE`. Subsequently, start and goal positions are staked out within the grid. The function `a_star()` from `planning_utils.py` is then used to generate a path from the start to the goal within to grid. Finally, the waypoints from the path are sent to the drone via `send_waypoints()`.

## Implementing Your Planning Algorithm ##

### *Set your global home position* ###

In lines 124-129 of `motion_planning.py`, the lat0 and lon0 values are extracted as floats from the first line of the `colliders.csv` file. Line 133 then uses those values to set the home position via `self.set_home_position()`.

### *Set your current local position* ###

In lines 138-145 of `motion_planning.py`, variables defining the current local north and east positions are set. As instructed, the global position is obtained from `self._longitude`, `self._latitude`, and `self._altitude` and then `self.global_home` is used in conjuction with that in `global_to_local()` to generate the local position. It should be noted that one could simply use `self.local_position` and `self.global_position` to retreive the local and global positions more directly. The local north and local east are converted to integers for use later in the code.

### *Set grid start position from local position* ###

In line 159 of `motion_planning.py`, the grid start position is set. Instead of subtracting the north and east offsets from the local home position (N: 0, E: 0), as originally provided in line 156, we subtract them from the current local position.

### *Set grid goal position from geodetic coords* ###

In lines 166-170 of `motion_planning.py`, a subjectively interesting latitude and longitude is selected, converted to local coordinates, and then set as the goal. The goal is the courtyard of a building nearby the home position. The `TARGET_ALTITUDE` was minimally raised so that the drone could fly over aforementioned building to enter the courtyard. Note, however, that for this planner implementation, raising the target altitude effectively means that the planner never sees the building containing the courtyard, as `create_grid()` will not enter it as an obstacle at that target altitude. Other goal positions can be tested by setting the longitude and latitude of `goal_position_global` in line 164.

### *Modify A\* to include diagonal motion (or replace A\* altogether)* ###

In lines 59-62 of `planning_utils.py`, the actions of diagonal motion in A* are defined and their cost set to be sqrt(2). Then, in lines 94-107 of `planning_utils.py`, if those diagonal motions are outside the grid or obstructed by obstacles, they are removed from the current list of valid actions.

### *Cull waypoints* ###

On line 180 of `motion_planning.py`, the waypoints are culled via collinearity, using the `prune_path()`, `collinearity_check()`, and `point()` functions added to `planning_utils.py` in lines 171-202. The implementation of those functions was taken from the class provided solution of `A-Star-City-Solution.ipynb` from the `Lesson 3.9 - Putting It Together Exercise`. The `prune_path()` function first makes a copy of the original path, and then iteratively reinterprets (via `point()`) a set of three consecutive points so that a determinant can be evaluated on the points and then compared to a sufficiently small value close to 0 in `collinearity_check()`. The determinant value represents the area of triangle created by the points, and, if the area is sufficiently small, the points can be deemed collinear. If the three consecutive points of the current iteration within `prune_path()` are tested as positively collinear, the middle point is removed from the running pruned path, and the collineaity test is run again from the same initial point. Otherwise, the start of the set of points to test is advanced to the next consecutive point.
